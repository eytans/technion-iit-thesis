
\subsection{Term Rewriting Systems}
\label{prelim:term-rewriting}

Consider a formal language $\Lang$ of terms over some vocabulary of symbols.
We use the notation $\Rewrite = t_1 \rwto t_2$ to denote a rewrite rule from $t_1$ to $t_2$.
For a (universally quantified) semantic equality law $t_1 = t_2$, we would normally create \emph{both}
$t_1 \rwto t_2$ and $t_2 \rwto t_1$.
We refrain from assigning a direction to equalities since we do not wish to restrict the procedure
to strongly normalizing systems, as is traditionally done in frameworks based on the Knuth-Bendix
algorithm~\cite{knuthbendixcompletion}.
Instead, we define equivalence when a sequence of rewrites can identify the terms in either direction.
A small caveat involves situations where $\FV(t_1)\neq\FV(t_2)$, that is, one side of the equality
contains variables that do not occur on the other.
We choose to admit only rules $t_i \rwto t_j$ where $\FV(t_i)\supseteq\FV(t_j)$, because when
$\FV(t_i)\subset \FV(t_j)$, applying the rewrite would have to create new symbols for the unassigned
variables in $t_j$, which results in a large growth in the number of symbols and typically makes
rewrites much slower as a result.

\medskip
This slight asymmetry is what motivates the following definitions.

\begin{definition}\label{screening:rw-equiv}
Given a rewrite rule $\Rewrite = t_1 \rwto t_2$, we define a corresponding relation
$\RewriteRelation{}{}$ such that $\RewriteRelation{s_1}{s_2} \iff s_1=C[t_1\sigma] \land s_2=C[t_2\sigma]$
for some context $C$ and substitution $\sigma$ for the free variables of $t_1, t_2$.
(A \emph{context} is a term with a single hole, and $C[t]$ denotes the term obtained by filling the
hole with $t$.)
\end{definition}

\begin{definition}\label{screening:symmetric}
Given a relation $\RewriteRelation{}{}$ we define its symmetric closure:

\centering
$\SRewriteRelation{t_1}{t_2} \iff \RewriteRelation{t_1}{t_2} ~\lor~ \RewriteRelation{t_2}{t_1}$
\end{definition}

\begin{definition}\label{screening:rw-set-equiv}
Given a set of rewrite rules $G_\Rewrite=\RewriteSys$, we define a relation as union of the relations of the rewrites: $\RewriteSysRelation{}{} \eqdef \bigcup_{i}\SRewriteRelationi{}{}$.\\
In the sequel, we will mostly use its reflexive transitive closure, $\TRewriteSysRelationSymbol$.
\end{definition}

The relation $\TRewriteSysRelationSymbol$ is reflexive, transitive, and symmetric,
so it is an equivalence relation over $\Lang$.
Under the assumption that all rewrite rules in $\RewriteSys$ are semantics preserving, for any equivalence class $[t] \in \Lang \big/ {\TRewriteSysRelationSymbol}\!$, all terms belonging to $[t]$ are definitionally equal.
However, since $\Lang$ may be infinite, it is essentially impossible to compute $\TRewriteSysRelationSymbol\!$.
Any algorithm can only explore a finite subset $\Terms \subseteq \Lang$, and in turn,
construct a subset of $\TRewriteSysRelationSymbol\!$.

\subsection{Compact Representation Using Equality Graphs}
\label{screening:representation}

In order to be able to cover a large set of terms $\Terms$, we need a
compact data structure that can efficiently represent many terms.
Normally, terms are represented by their ASTs
(Abstract Syntax Trees), but as there would
be many instances of common subterms among the terms of $\Terms$, 
this would be highly inefficient.
Instead, we adopt the concept of equality graphs (e-graphs) from automated theorem proving~\cite{JACM2005:Detlefs},
which also saw uses in compiler optimizations and program synthesis~\cite{POPL2009:Tate,herbie,PLDI2020:Nandi}, in which context they are known as Program Expression Graphs (PEGs).
%We benefit from they capacity
%to support efficient processing of rewrite rules over a large number of terms.
An e-graph is essentially a hypergraph where each vertex represents a set
of equivalent terms (programs), and labeled, directed hyperedges
represent function applications.
Hyperedges therefore have exactly one target and zero or more sources,
which form an ordered multiset (a vector, basically).
Just to illustrate, the expression
$\clrterm\tfilter~p~(l_1 \concat l_2)$
will be represented by the nodes and edges shown in dark in \autoref{prelim:peg}.
The nullary edges represent the constant symbols ($p$, $l_1$, $l_2$), and the node $u_0$ represents the entire term.
The expression 
$\clrterm\textrm{filter}~p~l_1 \concat \textrm{filter}~p~l_2$, which is equivalent, is represented by the light nodes and edges, and the equivalence is captured by sharing of the node $u_0$.

\begin{comment}
\[
\begin{array}{l}
    \langle \rangle \xrightarrow{p} u_1 \quad
    \langle \rangle \xrightarrow{l_1} u_2 \quad
    \langle \rangle \xrightarrow{l_2} u_3 \qquad
    \langle u_2, u_3 \rangle \xrightarrow{\concat} u_4 \quad
    \langle u_1, u_4 \rangle \xrightarrow{\textrm{filter}} u_5
\end{array}
\]
\end{comment}

\begin{SCfigure}[1.18][t]
\scalebox{.9}{
\input{thesy/img/peg}
}
\caption{An e-graph representing the expression
$\clrterm\textrm{filter}~p~(l_1 \concat l_2)$ (dark)
and the equivalent expression
$\clrterm\textrm{filter}~p~l_1 \concat \textrm{filter}~p~l_2$ (light).}
\label{prelim:peg}
\end{SCfigure}

When used in combination with a rewrite system $\RewriteSys$, each
rewrite rule is represented as a premise pattern $P$ and a conclusion pattern $C$.
Applying a rewrite rule is then reduced to searching the e-graph for the search pattern and obtaining a substitution $\sigma$ for the free variables of $P$.
The result term is then obtained by substituting the free variables of $C$ using $\sigma$.
This term is added to the same equivalence class as the matched term (\ie{} $P\sigma$), meaning they will both have the same root node.
Consequently, a single node can represent a set of terms
exponentially large in the number of edges, all of which will always be equivalent modulo 
$\TRewriteSysRelationSymbol$.


%Hyperedges are never replaced or removed, so that information about existing terms is preserved.
In addition, since hyperedges always represent functions, a situation may arise
in which two vertices represent the same term:
This happens if two edges $\bar{u}\xrightarrow{\scriptscriptstyle f}v_1$ and $\bar{u}\xrightarrow{\scriptscriptstyle f}v_2$
are introduced by $\RewriteSys$ for $v_1\neq v_2$.
In a purely functional setting, this means that $v_1$ and $v_2$ are equal.
Therefore, when such duplication is found,
it is beneficial to \emph{merge} $v_1$ and $v_2$, eliminating the duplicate hyperedge.
The e-graph data structure therefore supports a vertex merge operation and a congruence closure-based
transformation~\cite{egg}
%, \emph{rebuilding} 
that finds vertices eligible for merge to keep the overall graph size small.
This procedure can be quite expensive, so it is only run periodically.
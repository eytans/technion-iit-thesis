\section{Introduction}
\label{intro}

E-graphs are a versatile data structure that is used for various tasks of automated reasoning, including theorem proving and synthesis.
They are especially effective in reasoning about equality.
E-graphs have been popularized in compiler optimizations thanks to their ability to support efficient \emph{rewrites} over a large set of terms, while keeping a compact representation of all possible rewrite outcomes.
This mechanism is known as \emph{equality saturation}.
It provides a powerful engine that allows a reasoner to generate all equality consequences of a set of known, universally quantified equalities.
Possible uses include selecting the best version of an expression according to some desired metric, such as run-time efficiency~\cite{comp-optimizations}, size~\cite{DBLP:conf/fmcad/FlattCWTP22,DBLP:conf/fmcad/NotzliBNPRBT22}, or precision~\cite{herbie}
(when used as a compilation phase)
and a generalized form of unification, called e-unification, for application of inference steps (when used for proof search).

In this work we focus on \emph{exploratory reasoning} tasks such as theory exploration \cite{thesy}, rewrite rule inference \cite{ruler}, and proof search \cite{vampire,cyclist,cycleq,others}.
In these types of work, there are candidate goals that are being constructed gradually.
For example, a prover may have many proof goals (typically, sequents $\varphi\vdash\psi$) floating around---these are candidates for ``growing'' a proof tree that is being constructed gradually.
To be able to cope with this setting, we extend e-graphs with the capability to hold various assumptions simultaneously.

Normally, in an e-graph, assumptions added to it propagate throughout the graph, making it impossible to tell which equality is a consequence of which assumption.
A straightforward solution would be to create a separate copy of the graph for every assumption $\varphi$ (or set of such assumptions).
Clearly, this approach can become extremely costly in am exploratory setting where the bag of candidates may contain many different assumptions.

\begin{comment}
In this work we focus on the proof-search use case, where a prover may have many proof goals (typically, sequents $\varphi\vdash\psi$) floating around---these are candidates for ``growing'' a proof tree that is being constructed gradually.
To be able to cope with this setting, we extend e-graphs with the capability to hold various assumptions simultaneously.
Normally, in an e-graph, assumptions added to it propagate throughout the graph, making it impossible to tell which equality is a consequence of which assumption.
A straightforward solution would be to create a separate copy of the graph for every assumption $\varphi$ (or set of such assumptions).
Clearly, this approach can become extremely costly in a proof-search setting where the bag of candidates held by the prover contains many different assumptions. [refer to Vampire and others].    
\end{comment}

We address the problem of managing an e-graph in an automated reasoning scenario where many assumptions are needed and must be kept around to facilitate discovery of new assumptions and conclusions.
In such circumstances, the e-graph cloning approach will quickly run out of memory,
severely limiting scalability.
Our approach, \emph{colored e-graphs}, is based on admitting shared terms as single copies,
and keep track of terms that are equivalent only under certain assumptions.
These separate sub-spaces induce a coarsening of the congruence relation present in the base e-graph:
a set of e-classes, each of which itself a set of equivalent terms, can be further merged into a
\emph{colored e-class}, where the color denotes an assumption or assumptions that make all its members equivalent.

To illustrates how colored e-graphs can dramatically reduce the amount of memory required by multiple e-graphs,
consider the task of proving the simple equality:
\[\tfilter~p~(\tfilter~q~[x,y]) =
  \tfilter~q~(\tfilter~p~[x,y])\]

Where the definition of $\tfilter$ is
\[\tfilter~p~(x::xs) = 
\tif~p~x~\tthen~x::\tfilter~p~xs 
~\telse~\tfilter~p~xs\]

When rewriting, \eg, $\tfilter~p~[x,y]$,
the conditional causes the rewrite to 
block---because the truth value of $p~x$
is not known,
and so the rewriter cannot know which branch
to choose.
\emph{Case splitting}, a common automated
reasoning step, is then needed to introduce
alternative assumptions $p~x$ and $\lnot p~x$ and consider each one.
In the basic approach of cloning the e-graph,
we will have one copy in which 
$\tfilter~p~[x,y] \cong x::\tfilter~p~[y]$
(where $\cong$ denotes the congruence relation, meaning terms that reside in the same e-class)
and one copy in which 
$\tfilter~p~[x,y] \cong \tfilter~p~[y]$.
The two copies will have a shared term
$\tfilter~p~[y]$, but this cannot be taken advantage of, because the copies are disjoint;
therefore any rewrite that applies to the term will now have to be carried out twice, doubling both time and memory consumption.
Furthermore, rewriting of this latter term will similarly have to case-split on $p~y$,
so each copy will have to be cloned again.
This, even though the rewriting of $\tfilter~p~[y]$ depends only on $p~y$ and is agnostic to $p~x$.
Moving on, when further rewriting of
the terms in the equality above, the problem exacerbates because $q~x$, $q~y$ also occur in conditions, perpetrating additional case-splits, in different orders, leading to a lot of duplication as well as redundant, repeated work.

Our key observation, is that each assumption may lead to additional unions, but may never ``break apart'' classes of terms.
Due to this, each union done on the assumption-less equivalence relation, which we call the ``root'' congruence relation, will also be correct on any other congruence relation with additional assumptions.
This observation is important because such unions in the root can be shared across all other derived relations.
We extend the e-graph data structure to maintain multiple congruence relations at once, without having to duplicate the terms, by holding a union-find structure for each such relation.
We also extend the e-graph logic in several key ways, to support all its operations.
First, we set up a multi-level union-find where the lowest level corresponds to the ``root'' equivalence relation, that is,
terms that are equal independent of any assumptions.
Higher levels define further unions of e-class representatives from the lower one,
giving a coarsening of the root relation.
Second, we change how congruence closure is applied to the individual congruence relations while taking advantage of the sharing between each such relation and the root. 
Lastly, we present a technique for e-matching over all the relations at once.

We present an implementation of colored e-graphs based on state-of-the-art e-graph library egg~\cite{egg}.
The colored e-graphs semantics and basic implementation is discussed in \autoref{overview}, including its memory use improvements and run-time limitations.
In \autoref{optimizations} additional improvements are presented to .
Then experiments in \autoref{eval} show colored e-graphs to have efficient memory use while 

\begin{comment}
Multiple challenges present themselves when attempting to make these modifications to state-of-the-art e-graph implementations such as egg~\cite{egg}.
\SI{I think this paragraph and the list are no longer needed here because we have a better explanation in II}
 Normally, E-Graphs are built using a few key data structures that have been shown to be critical to the
effective performance of e-graphs:
\begin{enumerate}
  \item A union-find data structure for
      maintaining the set of equivalence classes
      that are created by non-destructive
      rewrite operations.
      Such rewrites are run frequently, making
      performance of the above significant.
  \item A hash table (hashcons) that maps e-nodes (AST nodes of terms in the e-graph) to their equality classes
  \item Collection of nodes for each equivalence class used for E-Matching
  \item A list of parents used for congruence closure
\end{enumerate}
To be efficient in memory usage, each color should only hold it's union find, but that leaves the open question on how to implement E-Matching, Rebuild, and Add. 

\ES{We are missing contrubutions, results and maybe some conclusion}

\end{comment}

% canonization
% map from id to set of colors and equivalent ids in each color


Half old intro:

% Gap
When encountering a term like $\tif~p\,x$, previous work based on rewriting, specifically equality saturation, either leaves it as opaque, or performs \emph{case splitting} by forking the entire state (in this case, the e-graph).
Case splitting, a common reasoning step, is needed to introduce alternative assumptions $p\,x$ and $\lnot p\,x$ and consider each one.
With the forking case splitting method we will have one copy in which 
$\tfilter~p~[x,y]$ rewrites to $x::\tfilter~p~[y]$
and one copy in which 
it rewrites to $\tfilter~p~[y]$.
The two copies will have a shared term
$\tfilter~p~[y]$, but this cannot be taken advantage of, because the copies are disjoint;
therefore any rewrite that applies to the term will now have to be carried out twice, doubling both time and memory consumption.
Furthermore, rewriting of this latter term, $\tfilter~p~[y]$, will similarly have to case-split on $p\,y$,
so each copy will have to be cloned again.
This, even though the rewriting of $\tfilter~p~[y]$ depends only on $p\,y$ and is agnostic to which case of $p\,x$ is taken.
Further rewriting of the terms in the equality above exacerbates problem, because $q\,x$, $q\,y$ also occur in conditions, perpetrating additional case-splits, and leading to even more duplication ($\times16$) as well as redundant, repeated work.
In larger examples, the reasoner will quickly exhaust the available memory as a result.

We note that in exploratory tasks it is often necessary to keep all the exploration paths rather than ``finish off'' proof branches iteratively.
The reason is that an incomplete path can be extended later in the exploration with the help of other conclusions.
This makes backtracking based approaches, like SMT solvers, inappropriate, and the memory limitation of duplications acute to these scenarios.

% Innovation
Our key observation is that each assumption may lead to additional unions, but may never ``break apart'' classes of terms.
An e-graph naturally represents a congruence relation $\cong$, which is an equality relation over terms (with function applications), which  maintains $x \cong y \vdash f(x) \cong f(y)$.
Any union done on the assumption-less congruence relation, which we call the ``root'' congruence relation, will also be correct on any forked e-graph's congruence relation that holds additional assumptions.
This observation is important because such unions in the root can be shared across all other derived e-graphs.

We extend the e-graph data structure into a \emph{Colored E-Graph} to maintain multiple congruence relations at once, where each relation is associated with a color.
A colored e-graph contains multiple congruence relations without having to duplicate the shared terms, by holding a union-find structure for each relation.
For the example above, we will use a colored e-graph with different colors for assumptions on the truth value of the $\tif$ condition, $p\,x$. 
The root $\cong$ will be represented by the color black.
The color \cblue will represent the assumption $p\,x$, which we denote $p\,x \congblue \ttrue$, and the color \cred will represent $\lnot p\,x$ which we denote $p\,x \congred \tfalse$.
Equality saturation can now infer, via rewriting, the consequences $\tfilter~p~[x,y] \congblue x::\tfilter~p~[y]$ and $\tfilter~p~[x,y] \congred \tfilter~p~[y]$.
When creating the new \cblue and \cred, the term $\tfilter~p~[x,y]$ will not be copied; instead, it is shared with the black color.

In addition, having a hierarchy between different colors can further benefit from such sharing.
As mentioned, two new assumptions are needed for case splitting on the $\tif$ condition, $p\,y$.
Any conclusion in the preceding congruence relations, whether root or \cblue, is also true for new relations added for $p\,y$, on top of \cblue.
In addition, terms will still remain uncopied, as the sharing persists for the additional congruence relations.

We also extend the colored e-graph's logic in several key ways, to support e-graph operations for all the colors.
First, we set up a multi-level union-find where the lowest level corresponds to the root congruence.
Higher levels define further unions of e-class representatives from the lower ones, forming \emph{colored e-classes}, giving a coarsening of relations lower in the hierarchy.
Second, we change how congruence closure is applied to the individual congruence relations while taking advantage of the sharing between each such relation and the root. 
Lastly, we present a technique for e-matching over all the relations at once.

% Oh we are so good!
Our contributions:
\begin{enumerate}
    \item The observation that assumptions induce coarsened e-graphs that share much of the original structure. 
    \item Algorithms for colored e-graphs operations.
    \item Optimizations on top of the basic algorithms to significantly improve resource usage.
    \item A colored e-graph implementation, \emph{Easter Egg}\footnote{\annon{\url{https://github.com/eytans/egg/tree/features/color_splits}}} and an evaluation that shows an improvement factor in memory usage over the existing baseline, while maintaining similar run-time performance.
\end{enumerate}